
def getGitHash(length) {
    def stdout = new ByteArrayOutputStream()
    exec {
        commandLine 'git', 'rev-parse', "--short=$length", 'HEAD'
        standardOutput = stdout
    }
    return stdout.toString().trim()
}

allprojects  {
  apply plugin: 'maven-publish'
  group = 'org.apache.yoko'
  version = '1.5.0.' + getGitHash(10)
}

subprojects {
  apply plugin: 'java'
  apply plugin: 'osgi'
  sourceCompatibility = 1.7
  targetCompatibility = 1.7

  repositories {
    mavenLocal()
    maven { url "http://repository.apache.org/snapshots" }
    maven { url "http://repo.maven.apache.org/maven2" }
  }

  configurations {
    // declare a new configuration to map to Maven's provided scope
    provided.transitive = true
    compile.extendsFrom provided
    // declare a new configuration to use for endorsed standards jars
    endorsed.transitive = true
    compile.extendsFrom endorsed
  }

  dependencies {}

  sourceSets.main.compileClasspath += configurations.provided

  publishing {
    publications {
      maven(MavenPublication) {
        artifact jar

        pom.withXml {
          def rootNode = asNode()

          // // specify packaging type as bundle (default is pom)
          // def packaging = root.packaging[0] ?:
          //                 root.appendNode('packaging')
          // packaging.setValue('bundle')

          def depsNode = rootNode.dependencies[0] ?:
                     rootNode.appendNode('dependencies')

          // declare 'provided' scope dependencies in the pom.xml
          // Note: the 'provided' scope is built into Maven,
          // but it is a custom configuration in this Gradle
          configurations.provided.allDependencies.each {
            def depNode = depsNode.appendNode('dependency')
            depNode.appendNode('groupId', it.group)
            depNode.appendNode('artifactId', it.name)
            depNode.appendNode('version', it.version)
            depNode.appendNode('scope', 'provided')
          }

          // declare 'endorsed' scope dependencies in the pom.xml
          // as compile dependencies
          configurations.compile.allDependencies.each {
            def depNode = depsNode.appendNode('dependency')
            depNode.appendNode('groupId', it.group)
            depNode.appendNode('artifactId', it.name)
            depNode.appendNode('version', it.version)
            depNode.appendNode('scope', 'compile')
          }
        }
      }
    }
  }

  jar {
    dependsOn "generatePomFileForMavenPublication"
    // generate the maven dependency metadata
    into("/META-INF/maven/$project.group/$project.name") {
      from 'build/publications/maven'
      rename "pom-default.xml", "pom.xml"
    }
    manifest {
      instruction 'Bundle-DocURL'          , "http://geronimo.apache.org/maven/yoko/$project.version/$project.name"
      instruction 'Bundle-License'         , 'http://www.apache.org/licenses/LICENSE-2.0.txt'
      instruction 'Bundle-Vendor'          , 'The Apache Software Foundation'
      instruction 'Import-Package'         , '!sun.*', '*'
    }
  }

  publish.dependsOn build
  // generated tasks need to be expressed as strings
  // because they don't exist yet when these lines are executed
  publish.dependsOn "publishMavenPublicationToMavenLocal"
  publish.dependsOn "publishToMavenLocal"

  // Add a task to copy the endorsed jars into a folder
  task stageEndorsed(type: Sync) {
    from configurations.endorsed
    into temporaryDir
  }

  // Make all compilation tasks use the endorsed dir
  tasks.withType(JavaCompile) {
    dependsOn stageEndorsed
    options.compilerArgs << "-Djava.endorsed.dirs=$stageEndorsed.destinationDir"
  }

  // Make execute tasks use the endorsed dir
  tasks.withType(Test) {
    dependsOn stageEndorsed
    jvmArgs "-Djava.endorsed.dirs=$stageEndorsed.destinationDir"
  }

  // ensure tests run under $buildDir somewhere
  test {
    workingDir = "$buildDir/testWorkingDir"
    doFirst {workingDir.mkdirs()}
    testLogging {
      // set options for log level LIFECYCLE
      events "passed", "skipped", "failed", "standardOut"
      showExceptions true
      exceptionFormat "full"
      showCauses true
      showStackTraces true

      // set options for log level DEBUG and INFO
      debug {
        events "started", "passed", "skipped", "failed", "standardOut", "standardError"
        exceptionFormat "full"
      }
      info.events = debug.events
      info.exceptionFormat = debug.exceptionFormat

      afterSuite { desc, result ->
        if (!desc.parent) { // will match the outermost suite
          def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
          def startItem = '|  ', endItem = '  |'
          def repeatLength = startItem.length() + output.length() + endItem.length()
          println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
        }
      }
    }
  }
}
